// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: healthdata.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum HealthTypes: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case workoutMain // = 0
  case categorySleepAnalysis // = 1
  case categoryAppleStandHour // = 2
  case categoryCervicalMucusQuality // = 3
  case categoryOvulationTestResult // = 4
  case categoryMenstrualFlow // = 5
  case categoryIntermenstrualBleeding // = 6
  case categorySexualActivity // = 7
  case categoryMindfulSession // = 8
  case categoryHighHeartRateEvent // = 9
  case categoryLowHeartRateEvent // = 10
  case categoryIrregularHeartRhythmEvent // = 11
  case quantityBodyMassIndex // = 12
  case quantityBodyFatPercentage // = 13
  case quantityHeight // = 14
  case quantityBodyMass // = 15
  case quantityLeanBodyMass // = 16
  case quantityStepCount // = 17
  case quantityDistanceWalkingRunning // = 18
  case quantityDistanceCycling // = 19
  case quantityBasalEnergyBurned // = 20
  case quantityActiveEnergyBurned // = 21
  case quantityFlightsClimbed // = 22
  case quantityNikeFuel // = 23
  case quantityHeartRate // = 24
  case quantityBodyTemperature // = 25
  case quantityBasalBodyTemperature // = 26
  case quantityBloodPressureSystolic // = 27
  case quantityBloodPressureDiastolic // = 28
  case quantityRespiratoryRate // = 29
  case quantityOxygenSaturation // = 30
  case quantityPeripheralPerfusionIndex // = 31
  case quantityBloodGlucose // = 32
  case quantityNumberOfTimesFallen // = 33
  case quantityElectrodermalActivity // = 34
  case quantityInhalerUsage // = 35
  case quantityBloodAlcoholContent // = 36
  case quantityForcedVitalCapacity // = 37
  case quantityForcedExpiratoryVolume1 // = 38
  case quantityPeakExpiratoryFlowRate // = 39
  case quantityDietaryFatTotal // = 40
  case quantityDietaryFatPolyunsaturated // = 41
  case quantityDietaryFatMonounsaturated // = 42
  case quantityDietaryFatSaturated // = 43
  case quantityDietaryCholesterol // = 44
  case quantityDietarySodium // = 45
  case quantityDietaryCarbohydrates // = 46
  case quantityDietaryFiber // = 47
  case quantityDietarySugar // = 48
  case quantityDietaryEnergyConsumed // = 49
  case quantityDietaryProtein // = 50
  case quantityDietaryVitaminA // = 51
  case quantityDietaryVitaminB6 // = 52
  case quantityDietaryVitaminB12 // = 53
  case quantityDietaryVitaminC // = 54
  case quantityDietaryVitaminD // = 55
  case quantityDietaryVitaminE // = 56
  case quantityDietaryVitaminK // = 57
  case quantityDietaryCalcium // = 58
  case quantityDietaryIron // = 59
  case quantityDietaryThiamin // = 60
  case quantityDietaryRiboflavin // = 61
  case quantityDietaryNiacin // = 62
  case quantityDietaryFolate // = 63
  case quantityDietaryBiotin // = 64
  case quantityDietaryPantothenicAcid // = 65
  case quantityDietaryPhosphorus // = 66
  case quantityDietaryIodine // = 67
  case quantityDietaryMagnesium // = 68
  case quantityDietaryZinc // = 69
  case quantityDietarySelenium // = 70
  case quantityDietaryCopper // = 71
  case quantityDietaryManganese // = 72
  case quantityDietaryChromium // = 73
  case quantityDietaryMolybdenum // = 74
  case quantityDietaryChloride // = 75
  case quantityDietaryPotassium // = 76
  case quantityDietaryCaffeine // = 77
  case quantityDietaryWater // = 78
  case quantityUvExposure // = 79
  case quantityAppleExerciseTime // = 80
  case quantityDistanceWheelchair // = 81
  case quantityPushCount // = 82
  case quantityDistanceSwimming // = 83
  case quantitySwimmingStrokeCount // = 84
  case quantityWaistCircumference // = 85
  case quantityVo2Max // = 86
  case quantityRestingHeartRate // = 87
  case quantityWalkingHeartRateAverage // = 88
  case quantityHeartRateVariabilitySdnn // = 89
  case quantityInsulinDelivery // = 90
  case quantityDistanceDownhillSnowSports // = 91
  case characteristicBiologicalSex // = 92
  case characteristicBloodType // = 93
  case characteristicDateOfBirth // = 94
  case characteristicFitzpatrickSkinType // = 95
  case characteristicWheelchairUse // = 96
  case clinicalAllergyRecord // = 97
  case clinicalConditionRecord // = 98
  case clinicalImmunizationRecord // = 99
  case clinicalLabResultRecord // = 100
  case clinicalMedicationRecord // = 101
  case clinicalProcedureRecord // = 102
  case clinicalVitalSignRecord // = 103
  case documentCda // = 104
  case correlationBloodPressure // = 105
  case correlationFood // = 106
  case UNRECOGNIZED(Int)

  init() {
    self = .workoutMain
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .workoutMain
    case 1: self = .categorySleepAnalysis
    case 2: self = .categoryAppleStandHour
    case 3: self = .categoryCervicalMucusQuality
    case 4: self = .categoryOvulationTestResult
    case 5: self = .categoryMenstrualFlow
    case 6: self = .categoryIntermenstrualBleeding
    case 7: self = .categorySexualActivity
    case 8: self = .categoryMindfulSession
    case 9: self = .categoryHighHeartRateEvent
    case 10: self = .categoryLowHeartRateEvent
    case 11: self = .categoryIrregularHeartRhythmEvent
    case 12: self = .quantityBodyMassIndex
    case 13: self = .quantityBodyFatPercentage
    case 14: self = .quantityHeight
    case 15: self = .quantityBodyMass
    case 16: self = .quantityLeanBodyMass
    case 17: self = .quantityStepCount
    case 18: self = .quantityDistanceWalkingRunning
    case 19: self = .quantityDistanceCycling
    case 20: self = .quantityBasalEnergyBurned
    case 21: self = .quantityActiveEnergyBurned
    case 22: self = .quantityFlightsClimbed
    case 23: self = .quantityNikeFuel
    case 24: self = .quantityHeartRate
    case 25: self = .quantityBodyTemperature
    case 26: self = .quantityBasalBodyTemperature
    case 27: self = .quantityBloodPressureSystolic
    case 28: self = .quantityBloodPressureDiastolic
    case 29: self = .quantityRespiratoryRate
    case 30: self = .quantityOxygenSaturation
    case 31: self = .quantityPeripheralPerfusionIndex
    case 32: self = .quantityBloodGlucose
    case 33: self = .quantityNumberOfTimesFallen
    case 34: self = .quantityElectrodermalActivity
    case 35: self = .quantityInhalerUsage
    case 36: self = .quantityBloodAlcoholContent
    case 37: self = .quantityForcedVitalCapacity
    case 38: self = .quantityForcedExpiratoryVolume1
    case 39: self = .quantityPeakExpiratoryFlowRate
    case 40: self = .quantityDietaryFatTotal
    case 41: self = .quantityDietaryFatPolyunsaturated
    case 42: self = .quantityDietaryFatMonounsaturated
    case 43: self = .quantityDietaryFatSaturated
    case 44: self = .quantityDietaryCholesterol
    case 45: self = .quantityDietarySodium
    case 46: self = .quantityDietaryCarbohydrates
    case 47: self = .quantityDietaryFiber
    case 48: self = .quantityDietarySugar
    case 49: self = .quantityDietaryEnergyConsumed
    case 50: self = .quantityDietaryProtein
    case 51: self = .quantityDietaryVitaminA
    case 52: self = .quantityDietaryVitaminB6
    case 53: self = .quantityDietaryVitaminB12
    case 54: self = .quantityDietaryVitaminC
    case 55: self = .quantityDietaryVitaminD
    case 56: self = .quantityDietaryVitaminE
    case 57: self = .quantityDietaryVitaminK
    case 58: self = .quantityDietaryCalcium
    case 59: self = .quantityDietaryIron
    case 60: self = .quantityDietaryThiamin
    case 61: self = .quantityDietaryRiboflavin
    case 62: self = .quantityDietaryNiacin
    case 63: self = .quantityDietaryFolate
    case 64: self = .quantityDietaryBiotin
    case 65: self = .quantityDietaryPantothenicAcid
    case 66: self = .quantityDietaryPhosphorus
    case 67: self = .quantityDietaryIodine
    case 68: self = .quantityDietaryMagnesium
    case 69: self = .quantityDietaryZinc
    case 70: self = .quantityDietarySelenium
    case 71: self = .quantityDietaryCopper
    case 72: self = .quantityDietaryManganese
    case 73: self = .quantityDietaryChromium
    case 74: self = .quantityDietaryMolybdenum
    case 75: self = .quantityDietaryChloride
    case 76: self = .quantityDietaryPotassium
    case 77: self = .quantityDietaryCaffeine
    case 78: self = .quantityDietaryWater
    case 79: self = .quantityUvExposure
    case 80: self = .quantityAppleExerciseTime
    case 81: self = .quantityDistanceWheelchair
    case 82: self = .quantityPushCount
    case 83: self = .quantityDistanceSwimming
    case 84: self = .quantitySwimmingStrokeCount
    case 85: self = .quantityWaistCircumference
    case 86: self = .quantityVo2Max
    case 87: self = .quantityRestingHeartRate
    case 88: self = .quantityWalkingHeartRateAverage
    case 89: self = .quantityHeartRateVariabilitySdnn
    case 90: self = .quantityInsulinDelivery
    case 91: self = .quantityDistanceDownhillSnowSports
    case 92: self = .characteristicBiologicalSex
    case 93: self = .characteristicBloodType
    case 94: self = .characteristicDateOfBirth
    case 95: self = .characteristicFitzpatrickSkinType
    case 96: self = .characteristicWheelchairUse
    case 97: self = .clinicalAllergyRecord
    case 98: self = .clinicalConditionRecord
    case 99: self = .clinicalImmunizationRecord
    case 100: self = .clinicalLabResultRecord
    case 101: self = .clinicalMedicationRecord
    case 102: self = .clinicalProcedureRecord
    case 103: self = .clinicalVitalSignRecord
    case 104: self = .documentCda
    case 105: self = .correlationBloodPressure
    case 106: self = .correlationFood
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .workoutMain: return 0
    case .categorySleepAnalysis: return 1
    case .categoryAppleStandHour: return 2
    case .categoryCervicalMucusQuality: return 3
    case .categoryOvulationTestResult: return 4
    case .categoryMenstrualFlow: return 5
    case .categoryIntermenstrualBleeding: return 6
    case .categorySexualActivity: return 7
    case .categoryMindfulSession: return 8
    case .categoryHighHeartRateEvent: return 9
    case .categoryLowHeartRateEvent: return 10
    case .categoryIrregularHeartRhythmEvent: return 11
    case .quantityBodyMassIndex: return 12
    case .quantityBodyFatPercentage: return 13
    case .quantityHeight: return 14
    case .quantityBodyMass: return 15
    case .quantityLeanBodyMass: return 16
    case .quantityStepCount: return 17
    case .quantityDistanceWalkingRunning: return 18
    case .quantityDistanceCycling: return 19
    case .quantityBasalEnergyBurned: return 20
    case .quantityActiveEnergyBurned: return 21
    case .quantityFlightsClimbed: return 22
    case .quantityNikeFuel: return 23
    case .quantityHeartRate: return 24
    case .quantityBodyTemperature: return 25
    case .quantityBasalBodyTemperature: return 26
    case .quantityBloodPressureSystolic: return 27
    case .quantityBloodPressureDiastolic: return 28
    case .quantityRespiratoryRate: return 29
    case .quantityOxygenSaturation: return 30
    case .quantityPeripheralPerfusionIndex: return 31
    case .quantityBloodGlucose: return 32
    case .quantityNumberOfTimesFallen: return 33
    case .quantityElectrodermalActivity: return 34
    case .quantityInhalerUsage: return 35
    case .quantityBloodAlcoholContent: return 36
    case .quantityForcedVitalCapacity: return 37
    case .quantityForcedExpiratoryVolume1: return 38
    case .quantityPeakExpiratoryFlowRate: return 39
    case .quantityDietaryFatTotal: return 40
    case .quantityDietaryFatPolyunsaturated: return 41
    case .quantityDietaryFatMonounsaturated: return 42
    case .quantityDietaryFatSaturated: return 43
    case .quantityDietaryCholesterol: return 44
    case .quantityDietarySodium: return 45
    case .quantityDietaryCarbohydrates: return 46
    case .quantityDietaryFiber: return 47
    case .quantityDietarySugar: return 48
    case .quantityDietaryEnergyConsumed: return 49
    case .quantityDietaryProtein: return 50
    case .quantityDietaryVitaminA: return 51
    case .quantityDietaryVitaminB6: return 52
    case .quantityDietaryVitaminB12: return 53
    case .quantityDietaryVitaminC: return 54
    case .quantityDietaryVitaminD: return 55
    case .quantityDietaryVitaminE: return 56
    case .quantityDietaryVitaminK: return 57
    case .quantityDietaryCalcium: return 58
    case .quantityDietaryIron: return 59
    case .quantityDietaryThiamin: return 60
    case .quantityDietaryRiboflavin: return 61
    case .quantityDietaryNiacin: return 62
    case .quantityDietaryFolate: return 63
    case .quantityDietaryBiotin: return 64
    case .quantityDietaryPantothenicAcid: return 65
    case .quantityDietaryPhosphorus: return 66
    case .quantityDietaryIodine: return 67
    case .quantityDietaryMagnesium: return 68
    case .quantityDietaryZinc: return 69
    case .quantityDietarySelenium: return 70
    case .quantityDietaryCopper: return 71
    case .quantityDietaryManganese: return 72
    case .quantityDietaryChromium: return 73
    case .quantityDietaryMolybdenum: return 74
    case .quantityDietaryChloride: return 75
    case .quantityDietaryPotassium: return 76
    case .quantityDietaryCaffeine: return 77
    case .quantityDietaryWater: return 78
    case .quantityUvExposure: return 79
    case .quantityAppleExerciseTime: return 80
    case .quantityDistanceWheelchair: return 81
    case .quantityPushCount: return 82
    case .quantityDistanceSwimming: return 83
    case .quantitySwimmingStrokeCount: return 84
    case .quantityWaistCircumference: return 85
    case .quantityVo2Max: return 86
    case .quantityRestingHeartRate: return 87
    case .quantityWalkingHeartRateAverage: return 88
    case .quantityHeartRateVariabilitySdnn: return 89
    case .quantityInsulinDelivery: return 90
    case .quantityDistanceDownhillSnowSports: return 91
    case .characteristicBiologicalSex: return 92
    case .characteristicBloodType: return 93
    case .characteristicDateOfBirth: return 94
    case .characteristicFitzpatrickSkinType: return 95
    case .characteristicWheelchairUse: return 96
    case .clinicalAllergyRecord: return 97
    case .clinicalConditionRecord: return 98
    case .clinicalImmunizationRecord: return 99
    case .clinicalLabResultRecord: return 100
    case .clinicalMedicationRecord: return 101
    case .clinicalProcedureRecord: return 102
    case .clinicalVitalSignRecord: return 103
    case .documentCda: return 104
    case .correlationBloodPressure: return 105
    case .correlationFood: return 106
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension HealthTypes: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [HealthTypes] = [
    .workoutMain,
    .categorySleepAnalysis,
    .categoryAppleStandHour,
    .categoryCervicalMucusQuality,
    .categoryOvulationTestResult,
    .categoryMenstrualFlow,
    .categoryIntermenstrualBleeding,
    .categorySexualActivity,
    .categoryMindfulSession,
    .categoryHighHeartRateEvent,
    .categoryLowHeartRateEvent,
    .categoryIrregularHeartRhythmEvent,
    .quantityBodyMassIndex,
    .quantityBodyFatPercentage,
    .quantityHeight,
    .quantityBodyMass,
    .quantityLeanBodyMass,
    .quantityStepCount,
    .quantityDistanceWalkingRunning,
    .quantityDistanceCycling,
    .quantityBasalEnergyBurned,
    .quantityActiveEnergyBurned,
    .quantityFlightsClimbed,
    .quantityNikeFuel,
    .quantityHeartRate,
    .quantityBodyTemperature,
    .quantityBasalBodyTemperature,
    .quantityBloodPressureSystolic,
    .quantityBloodPressureDiastolic,
    .quantityRespiratoryRate,
    .quantityOxygenSaturation,
    .quantityPeripheralPerfusionIndex,
    .quantityBloodGlucose,
    .quantityNumberOfTimesFallen,
    .quantityElectrodermalActivity,
    .quantityInhalerUsage,
    .quantityBloodAlcoholContent,
    .quantityForcedVitalCapacity,
    .quantityForcedExpiratoryVolume1,
    .quantityPeakExpiratoryFlowRate,
    .quantityDietaryFatTotal,
    .quantityDietaryFatPolyunsaturated,
    .quantityDietaryFatMonounsaturated,
    .quantityDietaryFatSaturated,
    .quantityDietaryCholesterol,
    .quantityDietarySodium,
    .quantityDietaryCarbohydrates,
    .quantityDietaryFiber,
    .quantityDietarySugar,
    .quantityDietaryEnergyConsumed,
    .quantityDietaryProtein,
    .quantityDietaryVitaminA,
    .quantityDietaryVitaminB6,
    .quantityDietaryVitaminB12,
    .quantityDietaryVitaminC,
    .quantityDietaryVitaminD,
    .quantityDietaryVitaminE,
    .quantityDietaryVitaminK,
    .quantityDietaryCalcium,
    .quantityDietaryIron,
    .quantityDietaryThiamin,
    .quantityDietaryRiboflavin,
    .quantityDietaryNiacin,
    .quantityDietaryFolate,
    .quantityDietaryBiotin,
    .quantityDietaryPantothenicAcid,
    .quantityDietaryPhosphorus,
    .quantityDietaryIodine,
    .quantityDietaryMagnesium,
    .quantityDietaryZinc,
    .quantityDietarySelenium,
    .quantityDietaryCopper,
    .quantityDietaryManganese,
    .quantityDietaryChromium,
    .quantityDietaryMolybdenum,
    .quantityDietaryChloride,
    .quantityDietaryPotassium,
    .quantityDietaryCaffeine,
    .quantityDietaryWater,
    .quantityUvExposure,
    .quantityAppleExerciseTime,
    .quantityDistanceWheelchair,
    .quantityPushCount,
    .quantityDistanceSwimming,
    .quantitySwimmingStrokeCount,
    .quantityWaistCircumference,
    .quantityVo2Max,
    .quantityRestingHeartRate,
    .quantityWalkingHeartRateAverage,
    .quantityHeartRateVariabilitySdnn,
    .quantityInsulinDelivery,
    .quantityDistanceDownhillSnowSports,
    .characteristicBiologicalSex,
    .characteristicBloodType,
    .characteristicDateOfBirth,
    .characteristicFitzpatrickSkinType,
    .characteristicWheelchairUse,
    .clinicalAllergyRecord,
    .clinicalConditionRecord,
    .clinicalImmunizationRecord,
    .clinicalLabResultRecord,
    .clinicalMedicationRecord,
    .clinicalProcedureRecord,
    .clinicalVitalSignRecord,
    .documentCda,
    .correlationBloodPressure,
    .correlationFood,
  ]
}

#endif  // swift(>=4.2)

struct HealthTypeList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var types: [HealthTypes] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HealthDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: HealthTypes = .workoutMain

  var startDate: String = String()

  var endDate: String = String()

  var limit: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HealthDataRequestList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requests: [HealthDataRequest] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HealthData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: HealthTypes {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var objectType: String {
    get {return _storage._objectType}
    set {_uniqueStorage()._objectType = newValue}
  }

  var startDate: String {
    get {return _storage._startDate}
    set {_uniqueStorage()._startDate = newValue}
  }

  var endDate: String {
    get {return _storage._endDate}
    set {_uniqueStorage()._endDate = newValue}
  }

  var device: String {
    get {return _storage._device}
    set {_uniqueStorage()._device = newValue}
  }

  var metadata: String {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  var uuid: String {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  var source: HealthData.SourceRevision {
    get {return _storage._source ?? HealthData.SourceRevision()}
    set {_uniqueStorage()._source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return _storage._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {_uniqueStorage()._source = nil}

  var specificData: OneOf_SpecificData? {
    get {return _storage._specificData}
    set {_uniqueStorage()._specificData = newValue}
  }

  var emptyData: HealthData.EmptySpecificData {
    get {
      if case .emptyData(let v)? = _storage._specificData {return v}
      return HealthData.EmptySpecificData()
    }
    set {_uniqueStorage()._specificData = .emptyData(newValue)}
  }

  var quantityData: HealthData.QuantitySpecificData {
    get {
      if case .quantityData(let v)? = _storage._specificData {return v}
      return HealthData.QuantitySpecificData()
    }
    set {_uniqueStorage()._specificData = .quantityData(newValue)}
  }

  var categoryData: HealthData.CategorySpecificData {
    get {
      if case .categoryData(let v)? = _storage._specificData {return v}
      return HealthData.CategorySpecificData()
    }
    set {_uniqueStorage()._specificData = .categoryData(newValue)}
  }

  var workoutData: HealthData.WorkoutSpecificData {
    get {
      if case .workoutData(let v)? = _storage._specificData {return v}
      return HealthData.WorkoutSpecificData()
    }
    set {_uniqueStorage()._specificData = .workoutData(newValue)}
  }

  var characteristicData: HealthData.CharacteristicSpecificData {
    get {
      if case .characteristicData(let v)? = _storage._specificData {return v}
      return HealthData.CharacteristicSpecificData()
    }
    set {_uniqueStorage()._specificData = .characteristicData(newValue)}
  }

  var clinicalRecordData: HealthData.ClinicalRecordSpecificData {
    get {
      if case .clinicalRecordData(let v)? = _storage._specificData {return v}
      return HealthData.ClinicalRecordSpecificData()
    }
    set {_uniqueStorage()._specificData = .clinicalRecordData(newValue)}
  }

  var documentData: HealthData.DocumentSpecificData {
    get {
      if case .documentData(let v)? = _storage._specificData {return v}
      return HealthData.DocumentSpecificData()
    }
    set {_uniqueStorage()._specificData = .documentData(newValue)}
  }

  var correlationData: HealthData.CorrelationSpecificData {
    get {
      if case .correlationData(let v)? = _storage._specificData {return v}
      return HealthData.CorrelationSpecificData()
    }
    set {_uniqueStorage()._specificData = .correlationData(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SpecificData: Equatable {
    case emptyData(HealthData.EmptySpecificData)
    case quantityData(HealthData.QuantitySpecificData)
    case categoryData(HealthData.CategorySpecificData)
    case workoutData(HealthData.WorkoutSpecificData)
    case characteristicData(HealthData.CharacteristicSpecificData)
    case clinicalRecordData(HealthData.ClinicalRecordSpecificData)
    case documentData(HealthData.DocumentSpecificData)
    case correlationData(HealthData.CorrelationSpecificData)

  #if !swift(>=4.1)
    static func ==(lhs: HealthData.OneOf_SpecificData, rhs: HealthData.OneOf_SpecificData) -> Bool {
      switch (lhs, rhs) {
      case (.emptyData(let l), .emptyData(let r)): return l == r
      case (.quantityData(let l), .quantityData(let r)): return l == r
      case (.categoryData(let l), .categoryData(let r)): return l == r
      case (.workoutData(let l), .workoutData(let r)): return l == r
      case (.characteristicData(let l), .characteristicData(let r)): return l == r
      case (.clinicalRecordData(let l), .clinicalRecordData(let r)): return l == r
      case (.documentData(let l), .documentData(let r)): return l == r
      case (.correlationData(let l), .correlationData(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  struct EmptySpecificData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct QuantitySpecificData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var count: Int64 = 0

    var quantityUnit: String = String()

    var quantity: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CategorySpecificData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct WorkoutSpecificData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var totalEnergyBurned: Double = 0

    var totalEnergyBurnedUnit: String = String()

    var totalDistance: Double = 0

    var totalDistanceUnit: String = String()

    var duration: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CharacteristicSpecificData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ClinicalRecordSpecificData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var displayName: String = String()

    var fhirResource: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct DocumentSpecificData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var authorName: String = String()

    var custodianName: String = String()

    var documentData: String = String()

    var patientName: String = String()

    var title: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CorrelationSpecificData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var objects: [HealthData] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SourceRevision {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var version: String = String()

    var operatingSystemVersion: String = String()

    var productType: String = String()

    var name: String = String()

    var bundleIdentifier: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct HealthDataList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: [HealthData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension HealthTypes: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WORKOUT_MAIN"),
    1: .same(proto: "CATEGORY_SLEEP_ANALYSIS"),
    2: .same(proto: "CATEGORY_APPLE_STAND_HOUR"),
    3: .same(proto: "CATEGORY_CERVICAL_MUCUS_QUALITY"),
    4: .same(proto: "CATEGORY_OVULATION_TEST_RESULT"),
    5: .same(proto: "CATEGORY_MENSTRUAL_FLOW"),
    6: .same(proto: "CATEGORY_INTERMENSTRUAL_BLEEDING"),
    7: .same(proto: "CATEGORY_SEXUAL_ACTIVITY"),
    8: .same(proto: "CATEGORY_MINDFUL_SESSION"),
    9: .same(proto: "CATEGORY_HIGH_HEART_RATE_EVENT"),
    10: .same(proto: "CATEGORY_LOW_HEART_RATE_EVENT"),
    11: .same(proto: "CATEGORY_IRREGULAR_HEART_RHYTHM_EVENT"),
    12: .same(proto: "QUANTITY_BODY_MASS_INDEX"),
    13: .same(proto: "QUANTITY_BODY_FAT_PERCENTAGE"),
    14: .same(proto: "QUANTITY_HEIGHT"),
    15: .same(proto: "QUANTITY_BODY_MASS"),
    16: .same(proto: "QUANTITY_LEAN_BODY_MASS"),
    17: .same(proto: "QUANTITY_STEP_COUNT"),
    18: .same(proto: "QUANTITY_DISTANCE_WALKING_RUNNING"),
    19: .same(proto: "QUANTITY_DISTANCE_CYCLING"),
    20: .same(proto: "QUANTITY_BASAL_ENERGY_BURNED"),
    21: .same(proto: "QUANTITY_ACTIVE_ENERGY_BURNED"),
    22: .same(proto: "QUANTITY_FLIGHTS_CLIMBED"),
    23: .same(proto: "QUANTITY_NIKE_FUEL"),
    24: .same(proto: "QUANTITY_HEART_RATE"),
    25: .same(proto: "QUANTITY_BODY_TEMPERATURE"),
    26: .same(proto: "QUANTITY_BASAL_BODY_TEMPERATURE"),
    27: .same(proto: "QUANTITY_BLOOD_PRESSURE_SYSTOLIC"),
    28: .same(proto: "QUANTITY_BLOOD_PRESSURE_DIASTOLIC"),
    29: .same(proto: "QUANTITY_RESPIRATORY_RATE"),
    30: .same(proto: "QUANTITY_OXYGEN_SATURATION"),
    31: .same(proto: "QUANTITY_PERIPHERAL_PERFUSION_INDEX"),
    32: .same(proto: "QUANTITY_BLOOD_GLUCOSE"),
    33: .same(proto: "QUANTITY_NUMBER_OF_TIMES_FALLEN"),
    34: .same(proto: "QUANTITY_ELECTRODERMAL_ACTIVITY"),
    35: .same(proto: "QUANTITY_INHALER_USAGE"),
    36: .same(proto: "QUANTITY_BLOOD_ALCOHOL_CONTENT"),
    37: .same(proto: "QUANTITY_FORCED_VITAL_CAPACITY"),
    38: .same(proto: "QUANTITY_FORCED_EXPIRATORY_VOLUME1"),
    39: .same(proto: "QUANTITY_PEAK_EXPIRATORY_FLOW_RATE"),
    40: .same(proto: "QUANTITY_DIETARY_FAT_TOTAL"),
    41: .same(proto: "QUANTITY_DIETARY_FAT_POLYUNSATURATED"),
    42: .same(proto: "QUANTITY_DIETARY_FAT_MONOUNSATURATED"),
    43: .same(proto: "QUANTITY_DIETARY_FAT_SATURATED"),
    44: .same(proto: "QUANTITY_DIETARY_CHOLESTEROL"),
    45: .same(proto: "QUANTITY_DIETARY_SODIUM"),
    46: .same(proto: "QUANTITY_DIETARY_CARBOHYDRATES"),
    47: .same(proto: "QUANTITY_DIETARY_FIBER"),
    48: .same(proto: "QUANTITY_DIETARY_SUGAR"),
    49: .same(proto: "QUANTITY_DIETARY_ENERGY_CONSUMED"),
    50: .same(proto: "QUANTITY_DIETARY_PROTEIN"),
    51: .same(proto: "QUANTITY_DIETARY_VITAMIN_A"),
    52: .same(proto: "QUANTITY_DIETARY_VITAMIN_B6"),
    53: .same(proto: "QUANTITY_DIETARY_VITAMIN_B12"),
    54: .same(proto: "QUANTITY_DIETARY_VITAMIN_C"),
    55: .same(proto: "QUANTITY_DIETARY_VITAMIN_D"),
    56: .same(proto: "QUANTITY_DIETARY_VITAMIN_E"),
    57: .same(proto: "QUANTITY_DIETARY_VITAMIN_K"),
    58: .same(proto: "QUANTITY_DIETARY_CALCIUM"),
    59: .same(proto: "QUANTITY_DIETARY_IRON"),
    60: .same(proto: "QUANTITY_DIETARY_THIAMIN"),
    61: .same(proto: "QUANTITY_DIETARY_RIBOFLAVIN"),
    62: .same(proto: "QUANTITY_DIETARY_NIACIN"),
    63: .same(proto: "QUANTITY_DIETARY_FOLATE"),
    64: .same(proto: "QUANTITY_DIETARY_BIOTIN"),
    65: .same(proto: "QUANTITY_DIETARY_PANTOTHENIC_ACID"),
    66: .same(proto: "QUANTITY_DIETARY_PHOSPHORUS"),
    67: .same(proto: "QUANTITY_DIETARY_IODINE"),
    68: .same(proto: "QUANTITY_DIETARY_MAGNESIUM"),
    69: .same(proto: "QUANTITY_DIETARY_ZINC"),
    70: .same(proto: "QUANTITY_DIETARY_SELENIUM"),
    71: .same(proto: "QUANTITY_DIETARY_COPPER"),
    72: .same(proto: "QUANTITY_DIETARY_MANGANESE"),
    73: .same(proto: "QUANTITY_DIETARY_CHROMIUM"),
    74: .same(proto: "QUANTITY_DIETARY_MOLYBDENUM"),
    75: .same(proto: "QUANTITY_DIETARY_CHLORIDE"),
    76: .same(proto: "QUANTITY_DIETARY_POTASSIUM"),
    77: .same(proto: "QUANTITY_DIETARY_CAFFEINE"),
    78: .same(proto: "QUANTITY_DIETARY_WATER"),
    79: .same(proto: "QUANTITY_UV_EXPOSURE"),
    80: .same(proto: "QUANTITY_APPLE_EXERCISE_TIME"),
    81: .same(proto: "QUANTITY_DISTANCE_WHEELCHAIR"),
    82: .same(proto: "QUANTITY_PUSH_COUNT"),
    83: .same(proto: "QUANTITY_DISTANCE_SWIMMING"),
    84: .same(proto: "QUANTITY_SWIMMING_STROKE_COUNT"),
    85: .same(proto: "QUANTITY_WAIST_CIRCUMFERENCE"),
    86: .same(proto: "QUANTITY_VO2_MAX"),
    87: .same(proto: "QUANTITY_RESTING_HEART_RATE"),
    88: .same(proto: "QUANTITY_WALKING_HEART_RATE_AVERAGE"),
    89: .same(proto: "QUANTITY_HEART_RATE_VARIABILITY_SDNN"),
    90: .same(proto: "QUANTITY_INSULIN_DELIVERY"),
    91: .same(proto: "QUANTITY_DISTANCE_DOWNHILL_SNOW_SPORTS"),
    92: .same(proto: "CHARACTERISTIC_BIOLOGICAL_SEX"),
    93: .same(proto: "CHARACTERISTIC_BLOOD_TYPE"),
    94: .same(proto: "CHARACTERISTIC_DATE_OF_BIRTH"),
    95: .same(proto: "CHARACTERISTIC_FITZPATRICK_SKIN_TYPE"),
    96: .same(proto: "CHARACTERISTIC_WHEELCHAIR_USE"),
    97: .same(proto: "CLINICAL_ALLERGY_RECORD"),
    98: .same(proto: "CLINICAL_CONDITION_RECORD"),
    99: .same(proto: "CLINICAL_IMMUNIZATION_RECORD"),
    100: .same(proto: "CLINICAL_LAB_RESULT_RECORD"),
    101: .same(proto: "CLINICAL_MEDICATION_RECORD"),
    102: .same(proto: "CLINICAL_PROCEDURE_RECORD"),
    103: .same(proto: "CLINICAL_VITAL_SIGN_RECORD"),
    104: .same(proto: "DOCUMENT_CDA"),
    105: .same(proto: "CORRELATION_BLOOD_PRESSURE"),
    106: .same(proto: "CORRELATION_FOOD"),
  ]
}

extension HealthTypeList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HealthTypeList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "types"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedEnumField(value: &self.types)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.types.isEmpty {
      try visitor.visitPackedEnumField(value: self.types, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthTypeList, rhs: HealthTypeList) -> Bool {
    if lhs.types != rhs.types {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HealthDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "startDate"),
    3: .same(proto: "endDate"),
    4: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.startDate)
      case 3: try decoder.decodeSingularStringField(value: &self.endDate)
      case 4: try decoder.decodeSingularInt32Field(value: &self.limit)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .workoutMain {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.startDate.isEmpty {
      try visitor.visitSingularStringField(value: self.startDate, fieldNumber: 2)
    }
    if !self.endDate.isEmpty {
      try visitor.visitSingularStringField(value: self.endDate, fieldNumber: 3)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthDataRequest, rhs: HealthDataRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.startDate != rhs.startDate {return false}
    if lhs.endDate != rhs.endDate {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthDataRequestList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HealthDataRequestList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requests"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.requests)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthDataRequestList, rhs: HealthDataRequestList) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HealthData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "objectType"),
    3: .same(proto: "startDate"),
    4: .same(proto: "endDate"),
    5: .same(proto: "device"),
    6: .same(proto: "metadata"),
    7: .same(proto: "uuid"),
    8: .same(proto: "source"),
    10: .same(proto: "emptyData"),
    11: .same(proto: "quantityData"),
    12: .same(proto: "categoryData"),
    13: .same(proto: "workoutData"),
    14: .same(proto: "characteristicData"),
    15: .same(proto: "clinicalRecordData"),
    16: .same(proto: "documentData"),
    17: .same(proto: "correlationData"),
  ]

  fileprivate class _StorageClass {
    var _type: HealthTypes = .workoutMain
    var _objectType: String = String()
    var _startDate: String = String()
    var _endDate: String = String()
    var _device: String = String()
    var _metadata: String = String()
    var _uuid: String = String()
    var _source: HealthData.SourceRevision? = nil
    var _specificData: HealthData.OneOf_SpecificData?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _objectType = source._objectType
      _startDate = source._startDate
      _endDate = source._endDate
      _device = source._device
      _metadata = source._metadata
      _uuid = source._uuid
      _source = source._source
      _specificData = source._specificData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._objectType)
        case 3: try decoder.decodeSingularStringField(value: &_storage._startDate)
        case 4: try decoder.decodeSingularStringField(value: &_storage._endDate)
        case 5: try decoder.decodeSingularStringField(value: &_storage._device)
        case 6: try decoder.decodeSingularStringField(value: &_storage._metadata)
        case 7: try decoder.decodeSingularStringField(value: &_storage._uuid)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._source)
        case 10:
          var v: HealthData.EmptySpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .emptyData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .emptyData(v)}
        case 11:
          var v: HealthData.QuantitySpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .quantityData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .quantityData(v)}
        case 12:
          var v: HealthData.CategorySpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .categoryData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .categoryData(v)}
        case 13:
          var v: HealthData.WorkoutSpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .workoutData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .workoutData(v)}
        case 14:
          var v: HealthData.CharacteristicSpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .characteristicData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .characteristicData(v)}
        case 15:
          var v: HealthData.ClinicalRecordSpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .clinicalRecordData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .clinicalRecordData(v)}
        case 16:
          var v: HealthData.DocumentSpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .documentData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .documentData(v)}
        case 17:
          var v: HealthData.CorrelationSpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .correlationData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .correlationData(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .workoutMain {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._objectType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._objectType, fieldNumber: 2)
      }
      if !_storage._startDate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._startDate, fieldNumber: 3)
      }
      if !_storage._endDate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._endDate, fieldNumber: 4)
      }
      if !_storage._device.isEmpty {
        try visitor.visitSingularStringField(value: _storage._device, fieldNumber: 5)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitSingularStringField(value: _storage._metadata, fieldNumber: 6)
      }
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 7)
      }
      if let v = _storage._source {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      switch _storage._specificData {
      case .emptyData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .quantityData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .categoryData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .workoutData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .characteristicData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .clinicalRecordData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .documentData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .correlationData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthData, rhs: HealthData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._objectType != rhs_storage._objectType {return false}
        if _storage._startDate != rhs_storage._startDate {return false}
        if _storage._endDate != rhs_storage._endDate {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._specificData != rhs_storage._specificData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthData.EmptySpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = HealthData.protoMessageName + ".EmptySpecificData"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthData.EmptySpecificData, rhs: HealthData.EmptySpecificData) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthData.QuantitySpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = HealthData.protoMessageName + ".QuantitySpecificData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "count"),
    102: .same(proto: "quantityUnit"),
    103: .same(proto: "quantity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeSingularInt64Field(value: &self.count)
      case 102: try decoder.decodeSingularStringField(value: &self.quantityUnit)
      case 103: try decoder.decodeSingularDoubleField(value: &self.quantity)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 101)
    }
    if !self.quantityUnit.isEmpty {
      try visitor.visitSingularStringField(value: self.quantityUnit, fieldNumber: 102)
    }
    if self.quantity != 0 {
      try visitor.visitSingularDoubleField(value: self.quantity, fieldNumber: 103)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthData.QuantitySpecificData, rhs: HealthData.QuantitySpecificData) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.quantityUnit != rhs.quantityUnit {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthData.CategorySpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = HealthData.protoMessageName + ".CategorySpecificData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeSingularInt64Field(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 101)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthData.CategorySpecificData, rhs: HealthData.CategorySpecificData) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthData.WorkoutSpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = HealthData.protoMessageName + ".WorkoutSpecificData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "totalEnergyBurned"),
    102: .same(proto: "totalEnergyBurnedUnit"),
    103: .same(proto: "totalDistance"),
    104: .same(proto: "totalDistanceUnit"),
    105: .same(proto: "duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeSingularDoubleField(value: &self.totalEnergyBurned)
      case 102: try decoder.decodeSingularStringField(value: &self.totalEnergyBurnedUnit)
      case 103: try decoder.decodeSingularDoubleField(value: &self.totalDistance)
      case 104: try decoder.decodeSingularStringField(value: &self.totalDistanceUnit)
      case 105: try decoder.decodeSingularDoubleField(value: &self.duration)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalEnergyBurned != 0 {
      try visitor.visitSingularDoubleField(value: self.totalEnergyBurned, fieldNumber: 101)
    }
    if !self.totalEnergyBurnedUnit.isEmpty {
      try visitor.visitSingularStringField(value: self.totalEnergyBurnedUnit, fieldNumber: 102)
    }
    if self.totalDistance != 0 {
      try visitor.visitSingularDoubleField(value: self.totalDistance, fieldNumber: 103)
    }
    if !self.totalDistanceUnit.isEmpty {
      try visitor.visitSingularStringField(value: self.totalDistanceUnit, fieldNumber: 104)
    }
    if self.duration != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 105)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthData.WorkoutSpecificData, rhs: HealthData.WorkoutSpecificData) -> Bool {
    if lhs.totalEnergyBurned != rhs.totalEnergyBurned {return false}
    if lhs.totalEnergyBurnedUnit != rhs.totalEnergyBurnedUnit {return false}
    if lhs.totalDistance != rhs.totalDistance {return false}
    if lhs.totalDistanceUnit != rhs.totalDistanceUnit {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthData.CharacteristicSpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = HealthData.protoMessageName + ".CharacteristicSpecificData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 101)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthData.CharacteristicSpecificData, rhs: HealthData.CharacteristicSpecificData) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthData.ClinicalRecordSpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = HealthData.protoMessageName + ".ClinicalRecordSpecificData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "displayName"),
    102: .same(proto: "fhirResource"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeSingularStringField(value: &self.displayName)
      case 102: try decoder.decodeSingularStringField(value: &self.fhirResource)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 101)
    }
    if !self.fhirResource.isEmpty {
      try visitor.visitSingularStringField(value: self.fhirResource, fieldNumber: 102)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthData.ClinicalRecordSpecificData, rhs: HealthData.ClinicalRecordSpecificData) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.fhirResource != rhs.fhirResource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthData.DocumentSpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = HealthData.protoMessageName + ".DocumentSpecificData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "authorName"),
    102: .same(proto: "custodianName"),
    103: .same(proto: "documentData"),
    104: .same(proto: "patientName"),
    105: .same(proto: "title"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeSingularStringField(value: &self.authorName)
      case 102: try decoder.decodeSingularStringField(value: &self.custodianName)
      case 103: try decoder.decodeSingularStringField(value: &self.documentData)
      case 104: try decoder.decodeSingularStringField(value: &self.patientName)
      case 105: try decoder.decodeSingularStringField(value: &self.title)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authorName.isEmpty {
      try visitor.visitSingularStringField(value: self.authorName, fieldNumber: 101)
    }
    if !self.custodianName.isEmpty {
      try visitor.visitSingularStringField(value: self.custodianName, fieldNumber: 102)
    }
    if !self.documentData.isEmpty {
      try visitor.visitSingularStringField(value: self.documentData, fieldNumber: 103)
    }
    if !self.patientName.isEmpty {
      try visitor.visitSingularStringField(value: self.patientName, fieldNumber: 104)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 105)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthData.DocumentSpecificData, rhs: HealthData.DocumentSpecificData) -> Bool {
    if lhs.authorName != rhs.authorName {return false}
    if lhs.custodianName != rhs.custodianName {return false}
    if lhs.documentData != rhs.documentData {return false}
    if lhs.patientName != rhs.patientName {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthData.CorrelationSpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = HealthData.protoMessageName + ".CorrelationSpecificData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "objects"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeRepeatedMessageField(value: &self.objects)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 101)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthData.CorrelationSpecificData, rhs: HealthData.CorrelationSpecificData) -> Bool {
    if lhs.objects != rhs.objects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthData.SourceRevision: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = HealthData.protoMessageName + ".SourceRevision"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "version"),
    102: .same(proto: "operatingSystemVersion"),
    103: .same(proto: "productType"),
    104: .same(proto: "name"),
    105: .same(proto: "bundleIdentifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeSingularStringField(value: &self.version)
      case 102: try decoder.decodeSingularStringField(value: &self.operatingSystemVersion)
      case 103: try decoder.decodeSingularStringField(value: &self.productType)
      case 104: try decoder.decodeSingularStringField(value: &self.name)
      case 105: try decoder.decodeSingularStringField(value: &self.bundleIdentifier)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 101)
    }
    if !self.operatingSystemVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.operatingSystemVersion, fieldNumber: 102)
    }
    if !self.productType.isEmpty {
      try visitor.visitSingularStringField(value: self.productType, fieldNumber: 103)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 104)
    }
    if !self.bundleIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleIdentifier, fieldNumber: 105)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthData.SourceRevision, rhs: HealthData.SourceRevision) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.operatingSystemVersion != rhs.operatingSystemVersion {return false}
    if lhs.productType != rhs.productType {return false}
    if lhs.name != rhs.name {return false}
    if lhs.bundleIdentifier != rhs.bundleIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthDataList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HealthDataList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthDataList, rhs: HealthDataList) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
